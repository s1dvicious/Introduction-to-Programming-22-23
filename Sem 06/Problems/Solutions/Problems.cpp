#include<iostream>

//Задача 1 Да се напише функция, която приема масив, в който всяко число се среща 2 пъти с изключение на едно число, което се среща веднъж.Напишете функция, която приема такъв масив и връща кое е това число. (Подсказка: използвайте побитови операции, за да постигнете линейно решение)
//Вход: [9 18 9 12 18 15 12] , Изход : 15

//Обяснение: имаме, че x^y = y^x и (x^y)^z = x^(y^z), т.е. ако масивът е {a0,a1,a2,...ak}, то
// а0^a1^a2...^ak-1^ak = aj^(a(0)^a(1))^(a(2)^a(3))^...^(a(k-1)^a(k)), т.че a(2j) = a(2j+1) за всяко j = 0,...k,то имаме
// = aj^0^...^0 = aj, който е и търсеният елемент. Т.е. единствено трябва да вземем XOR произведението на всички елементи в масива

int findSingle(const int arr[], const unsigned size) {

	int res = arr[0];

	for (unsigned i = 1; i < size; ++i) {
		res ^= arr[i];
	}

	return res;
}

//Задача 2 Напишете функция, която приема цяло число и връща броя на 1-ците в двоичния му запис.
//Вход: 189, Изход : 6

unsigned numberOfOnes(unsigned num) {

	unsigned counter = 0;

	while (num > 0) {

		if (num & 1) {
			++counter;
		}
		num >>= 1;
	}

	return counter;
}

//Задача 3 : Напишете функция, която приема цяло число и обръща най-десният бит в него, който е единица.
//Вход: 12, Изход : 140
//Вход : 15, Изход : 143

void flipRightMostOne(unsigned& num) {

	num &= num - 1;
	
}

//Задача 4 :Напишете функция, която приема цели числа n и k и обръща бита на k - та позиция в n(считаме, че индексацията започва от 1).
//* Вход : 12, Изход : 8 *
//*Вход : 15, Изход : 14 *

void flipBit(unsigned& number, unsigned pos) {
	std::bitset<32> x1(n);

	unsigned posBit = (1 << (pos - 1));
	std::bitset<32> x2(posBit);
	std::cout << x1 << std::endl << x2;

	n ^= (1 << (pos - 1));

	//1110 0 0110
	//0000 0 0001 << (5-1)
	//...000000000 1 0000
	//     ^
	//...000001110 1 0110
	//...000001110 0 0110
}

//Задача 5: Напишете функция, която по подадено цяло число n и цяло число k и връща числото, което е "закодирано" в последните k бита на n.
//Вход : 15 2, Изход : 3
//Вход : 189 3, Изход : 5
//Вход : 189 4, Изход : 13

unsigned encodedInFirst(unsigned n, unsigned k) {

	return (n & ((1 << k) - 1));

}

//Задача 6: Напишете функция, която приема цяло число n и цяло число k и връща дали k в двоичен запис(разглеждайки го без водещите 0 - ли) е част от двоичния запис на n.
//Вход : 15 3, Изход : true
//Вход : 13 5 Изход : true
//Вход : 13 7, Изход : false

bool isContainedIn(int n, int k) {
	return ((n & k) == k);
}



