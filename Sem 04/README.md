Да разгледаме следната задача:   

**Задача 1:** Въвежда се неотрицателно число n. Да се отпечатат всички двойки прости числа, които са във вида 6k-1 и  6k+1, и са по-малки от n.  

Задачата решаваме по следния начин:  

```c++
int main()
{
	int n;
	cin >> n;
	
	for (int i = 6; i < n; i += 6)
	{
		int firstToCheck = i - 1;
		int secondToCheck = i + 1;

		//prime check
		bool isFirstPrime = true;
		double temp = sqrt(firstToCheck);
		for (int j = 2; j <= temp; j++)
		{
			if (firstToCheck % j == 0)
				isFirstPrime = false;
		}

		if (!isFirstPrime)
			continue;

		//prime check
		bool isSecondPrime = true;
		double temp2 = sqrt(secondToCheck);
		for (int j = 2; j <= temp2; j++)
		{
			if (secondToCheck % j == 0)
				isSecondPrime = false;
		}

		if (isSecondPrime)
			cout << firstToCheck << " " << secondToCheck << endl;
	}
}
```
Забелязваме, че следното парче от код
```c++
//prime check
		bool isFirstPrime = true;
		double temp = sqrt(firstToCheck);
		for (int j = 2; j <= temp; j++)
		{
			if (firstToCheck % j == 0)
				isFirstPrime = false;
		}

		if (!isFirstPrime)
			continue;
```
се повтаря два пъти - и двата в контекста на две различни числа, но логиката се дублира, като това е една стандартна ситуация в програмирането, която целим да елиминираме доколкото е възможно. И така, въпросът е - не е ли възможно да съберем тези инструкции, като ги именуваме и вместо всеки път, когато ни е необходима тази конкретна функционалност - вместо да copy/paste-ваме, просто да извикаме името на тази група? Отговорът е положителен и той се дава от

## Функции

Функция представлява съвкупност от инструкции, която притежава име и може да се извика от всяко място в програмата. Синтаксисът при декларация (и дефиниция) на функция е  

```c++
<data-type> name(<parameter-1>, <parameter-2>,...,<parameter-n>){
   //statements  
   
  }
```
където:  
- ***data-type*** е типът (например char, float, int etc.) на стойността, който бихме получили като резултат в следствие на изпълнение на функцията (при return-ване);
- ***name*** - името или идентификатор, чрез който се извиква функцията - тук важат същите правила за именуване, както и при променливите;
- ***parameters*** - всеки параметър се състои от ***тип*** и ***идентификатор***, като всеки два параметъра се разделят със запетая. Те представляват нищо повече от декларация на една (локална за функцията) променлива. Предназначението им е да се позволи подаване на аргументи към функцията от мястото, на което тя бива извиквана;

### Пример:
```c++
int max(int n, int k){
return n > k? n: k;
}
```
и при main-a имаме:

```c++
int main(){
int x = 5,
    y = 10;
    
int z = max(x,y);

return 0;
}
```
тук при извикване на функцията max се взимат стойностите на променливите x и y, след което се задават на локалните за max променливи - n и k. В резултат се прави проверка и се връща стойността на по-голямото от двете числа. Забележете, че можем да постъпим и така
```c++
z = max(5, 10);
```
и тук аналогично литералите 5 и 10 се задават на n и k, като наредбата, в който се случва това отговаря на наредбата на параметрите.  
В момента на извикване при main функцията, управление на програмата се дава изцяло на функцията max: изпълнението на main-a спира и продължава едва тогава, когато завърши изпълнението на max. 

Например при горната задача онази функционалност, която можем да капсулираме в една функция е проверката за това дали (оттук и return type-a е bool) едно число е просто, а именно:  

```c++
bool isPrime(unsigned int k) {

	if (k <= 1) return false;

	double squareRoot = sqrt(k);

	for (size_t i = 2; i <= squareRoot; ++i) {
		if (k % i == 0) {
			return false;
		}
	}

	return true;
}
```
Тук return-type-a очевидно е булев - подаденото като параметър (положително, оттук и unsigned) число или е просто, или не е. Колкото до //statement частта на тази функция - логиката напълно се наследява от първоначалното решение на задачата. Важно нещо също е, че всички променливи, които се декларират в тялото биват локални за нея и се изтриват (от паметта) когато завърши изпълнението на функцията, т.е. те не могат да бъдат достъпвани извън този scope.  
Сега в main-a нещата изглеждат далеч по-чисти и прости:  
```c++
int main() {

	unsigned n;
	std::cin >> n;

	for (size_t k = 6; k < n; k += 6) {

		if (isPrime(k - 1) && isPrime(k + 1))
			std::cout << k - 1 << " " << k + 1 << std::endl;

	}

	return 0;
}
```
тук важното също е, че и при двете извиквания на функцията горе това, което се случва е, че се взима стойността, която се подава като параметър, и тя се задава на локалната (за isPrime) променлива - k, т.е. по този начин на извикване стойността се копира и се преизползва локално.

### Примери:

**Задача 1:** Въвежда се неотрицателно число n. Да се отпечатат всички двойки прости числа, които са във вида 6k-1 и  6k+1.

-решена без функции и решена с функции.

**Задача 2:** Напишете функция, която приема неотрицателно число n и връща числото обърнато

*Вход: 288, Изход: 882*

**Задача 3:** Напишете функция, която приема неотрицателно число и връща дали числото е палиндром.

*Вход: 2882 Изход: true*

**Задача 4:** Напишете функция, която приема неотрицателни числа n и k и връща дали k е суфикс на n.

*Вход: 288, 88, Изход: true*

**Задача 5:** Напишете функция, която приема неотрицателни числа n и k и връща дали k е префикс на n.

*Вход: 288, 28, Изход: true*

**Задача 6:** Напишете функция, която приема неотрицателни числа n и k и връща дали k е инфикс в n.

*Вход: 2831, 83, Изход: true*

**Задача 7:** Напишете функция, която приема неотрицателно число и връща дали цифрите му са сортирани (във възходящ или в низходящ ред).

*Вход: 122239,  Изход: true*

**Задача 8:** Напишете функция, която приема неотрицателно число и връща дали цифрите му са еднакви.

*Вход: 111111,  Изход: true*

**Задача 9:** Напишете функция, която приема неотрицателно числа n и k връща n^k

*Вход: 3 4,  Изход: 81*

**Задача 10:** Напишете функция, която приема неотрицателно числа n и k връща log_k(n) (закръглено надолу)

*Вход: 90 3  Изход: 4*


## Функции без return type - void
Горният синтаксис налага указване на конкретен тип, който връща функцията. Възможно е обаче функцията да не връща нищо, като в този случай <data-type>-а на функцията е void, като това е специален тип, който указва липса на стойност. Например следната функция, която само принтира на конзолата

```c++
void printHello(){

std::cout<<"Hello!\n";

}
```


## Подаване на параметри по стойност и референция

Да разгледаме следното парче код
```c++
void increment(int n){
++n;
}
	
int main(){
int n = 5;
increment(n);
std::cout<<n; //prints 5, i.e. the value is not incremented
	
return 0;
}
```
където предназначението на increment функцията е да инкрементира аргумента си с 1ца. Причината, поради която не се променя стойността на n след подаване на функцията е, че стойността и се копира и се подава на локалната за increment променлива. Обаче, възможно е и друг вид подаване, а именно на самата променлива (а не само на стойността й) и това става чрез т.нар. референции (псевдоними):
	
```c++
void increment(int& n){
++n;
}
	
int main(){
int n = 5;
increment(n);
std::cout<<n; //prints 6
	
return 0;
}
```
Т.е. вместо да копираме стойността, когато подаваме n като параметър - подаваме истинската променлива.  
В общи линии референциите представляват променливи, които служат като псевдоним на други променливи. Синтаксисът за декларация на референция е
```c++
int n = 5;
	
int& nRef = n;   // четем отдясно наляво - nRef е референция към int
++nRef;
	
std::cout<< n;  //prints 6, since n's value was incremented through a reference to n, namely through nRef
```
Важен детайл при тях е, че при декларация те трябва да бъдат инициализирани (вързани за друг обект). След инициализация, референцията не може да бъде насочена към друга променлива.  

## Стек на извикванията  
Преди всичко, всяка декларирана функция се запазва в паметта (транслира се в машинен код), като там се съдържа информация за всичките й компоненти - декларирани локални променливи, параметри, временни обекти и т.н.. 
В стековата памет извикванията се базират (както е и името) на принципа LIFO (Last In First Out), или на принципа на структурата от данни стек. Това поражда и еквивалентния термин ***стекова решетка*** за извикванията на функциите. Най-просто, всяко извикване на една функция заделя памет, която се държи в специално място, наречено стекова рамка за функцията (или просто запис за улеснение), - за параметрите си, а също и за всичките локални променливи, която тя декларира (включително променливата, която се връща). Последователността, в която се декларират променливите е - първо параметрите, след това локалните променливи и накрая връщаната.  
Да разгледаме следния пример  
```c++
void bar() {
}

void foo() {
  bar();
}

int main() {
  foo();
}
```
При изпълнение на програмата винаги първо се извиква ```main()``` функцията, като се записва извикването и се слага отгоре на стека. ```main()``` функцията извиква ```foo()```, като това извикване записва ```foo()``` отгоре на стека. След това се извиква ```bar()``` и се слага отгоре на стека. Когато приключи изпълението на ```bar()```, нейното извикване се премахва от стека. След това ```foo()``` се премахва, аналогично и ```main()``` в края на изпълнението си.  
Следната фигура показва състоянието на стека след всяко извикване  
<img src="https://i.imgur.com/IUGxJPF.jpg" width=100% height=100%>  
Да разгледаме следната една идея по-комплексна програма  
```c++
int plus_one(int x) {
  return x + 1;
}

int plus_two(int x) {
  return plus_one(x + 1);
}

int main() {
  int result = 0;
  result = plus_one(0);
  result = plus_two(result);
  std::cout << result;             // prints 3
}	
```
В началото на програмата ```main()``` се извиква първо, след което се прави запис, който държи една единствена локална променлива ```result```. След декларацията й тя се инициализира със стойност 0, след което се извиква ```plus_one(0)```. Това създава запис за ```plus_one()```, който съдържа параметър ```x```. Програмата задава стойност ```0``` на параметъра ```x```и се изпълнява тялото на функцията. Тялото изчислява стойността на ```(x+1)``` като взима стойността на ```x``` и добавя 1 към нея, като в резултат връща 1. Върнатата стойност 1 замества оригиналното извикване на ```plus_one(0)```, след което записа за ```plus_one()``` се изтрива от стека. След това се задава стойност 1 (върнатата от функцията) на променливата ```result```.  
Следната фигура илюстрира състоянията на стека в хода на горните изпълнения.	
<img src="https://i.imgur.com/w7M2vEr.jpg" width=100% height=100%> 
След това се продължава към извикването на ```plus_two(result)```. Първоначално на result се задава стойност 1 (от предишното извикване). След това се създава запис за ```plus_two()```, като за него се заделя памет за параметъра ```x```. Този запис се намира на същото място, където се е намирал и последния за извикването на ```plus_one(0)```, като това място се преизползва. След записа, параметърът ```x``` бива инициализиран със стойност 1. След това се изпълнява тялото на ```plus_two()```.  
Тялото на ```plus_two()``` извиква ```plus_one(x+1)```. Изчислява се стойността на x + 1 = 2, след което се създава запис за ```plus_one()```, като се заделя място за параметъра ```x``` и в новия запис стойността му е 2, като след това се изпълнява тялото на ```plus_one()```.
<img src="https://i.imgur.com/iKoSa9u.jpg" width=100% height=100%>  
Новосъздаденият за ```plus_one()``` запис е различен от предишния - всяко извикване си създава собствен такъв, като декларираните там променливи са локални за него си. 
	
## Статични и глобални променливи 
Статичните променливи са променливи, които не губят стойността (задържат я) след като излезнат извън scope-a, в който са декларирани. Следователно, статичните променливи запазват предишната си стойност и не биват инициализирани отново при следващо извикване. Например  
```c++	
void returnSomething() {
	int x = 0;

	std::cout << (x++)<<"\t";

}

int main() {

	for (int i = 0; i < 5; ++i) {
		returnSomething();
	}

	return 0;
}
```
получаваме изход  
```0 0 0 0 0```  
докато ако обявим x за статична,т.е. при декларацията ```static int x = 0``` получаваме изход  
```0 1 2 3 4```  
т.е. нейната стойност се запазва между извикванията на returnSomething().  
Глобални променливи наричаме променливи, които не са локални, т.е. не са декларирани във функции (и в каквито и да е други scope-ове). Например  
```c++
#include<iostream>
	
int b = 5;

int& increment() {
	return (++b);
}

int main() {

	for (int i = 0; i < 5; ++i) {
		std::cout << increment()<<" ";
	}

	return 0;
}			  
```  
изкарва ```6 7 8 9 10```.  

## Стойности по подразбиране на параметрите

Параметър с подразбираща се стойност в декларацията на една функция е параметър, на когото автоматично се задава стойност от компилатора, ако извикването на функцията не предостави такава. В случай, че такава се предостави - подразбиращата се стойност се заменя с тази, с която е извикана функцията. Например  
```c++
int sum(int x, int y, int z = 0, int w = 0) //assigning default values to z,w as 0
{
    return (x + y + z + w);
}
 

int main()
{
    // Statement 1
    cout << sum(10, 15) << endl;
   
    // Statement 2
    cout << sum(10, 15, 25) << endl;
   
    // Statement 3
    cout << sum(10, 15, 25, 30) << endl;
    return 0;
}
```
и получаваме изход  
```
25
50
80
```
Възможно е и да имаме и множество функции със същите: ***return type*** и име, но различен набор от параметри. Изборът на коя точно функция ще се изпълни става по време на компилация (compile-time polymorphism), като коя точно се извиква зависи изцяло от подадените параметри. Например  

```c++
void printSum(int x, int y) {
	std::cout << x + y << std::endl;
}

void printSum(double x, double y) {

	std::cout << x + y << std::endl;
}
int main()
{
	printSum(2, 3);        //
	printSum(20.5, 3.2);

		return 0;
}
```
